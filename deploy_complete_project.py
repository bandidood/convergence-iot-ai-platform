#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
üöÄ D√âPLOIEMENT COMPLET PROJET STATION TRAFFEY√àRE
IoT/IA Platform - RNCP 39394 - Test Final

Script de d√©ploiement et validation compl√®te de tous les composants
d√©velopp√©s pendant les 16 semaines du projet.
"""

import os
import sys
import time
import subprocess
import json
import asyncio
from pathlib import Path
import logging
from typing import Dict, List, Any, Optional

# Configuration logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('deployment.log'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class ProjectDeployer:
    """D√©ployeur complet du projet Station Traffey√®re"""
    
    def __init__(self):
        self.project_root = Path.cwd()
        self.services = []
        self.deployment_status = {}
        self.start_time = time.time()
        
        # Configuration des services √† d√©ployer
        self.service_config = {
            "iot_generator": {
                "path": "scripts/iot_data_generator.py",
                "port": 8090,
                "description": "G√©n√©rateur donn√©es IoT 127 capteurs"
            },
            "edge_ai_engine": {
                "path": "scripts/edge_ai_engine.py", 
                "port": 8091,
                "description": "Moteur IA Edge temps r√©el"
            },
            "prometheus": {
                "docker_compose": "docker-compose.monitoring.yml",
                "service": "prometheus",
                "port": 9090,
                "description": "Serveur m√©triques Prometheus"
            },
            "grafana": {
                "docker_compose": "docker-compose.yml",
                "service": "grafana",
                "port": 3001,
                "description": "Dashboard Grafana"
            },
            "soc_dashboard": {
                "path": "src/dashboard/soc_dashboard.py",
                "port": 8080,
                "description": "Dashboard SOC temps r√©el"
            },
            "validation_system": {
                "path": "week-16-global-expansion/final_validation_system.py",
                "description": "Syst√®me validation finale RNCP"
            }
        }

    def check_prerequisites(self) -> bool:
        """V√©rification pr√©requis syst√®me"""
        logger.info("Verification prerequisites...")
        
        prerequisites = {
            "python": {"command": "python --version", "required": True},
            "docker": {"command": "docker --version", "required": True},
            "docker-compose": {"command": "docker-compose --version", "required": False},
            "pip": {"command": "pip --version", "required": True}
        }
        
        all_good = True
        for name, config in prerequisites.items():
            try:
                result = subprocess.run(
                    config["command"].split(), 
                    capture_output=True, 
                    text=True, 
                    timeout=10
                )
                if result.returncode == 0:
                    version = result.stdout.strip().split('\n')[0]
                    logger.info(f"‚úÖ {name}: {version}")
                else:
                    if config["required"]:
                        logger.error(f"‚ùå {name}: Non disponible (requis)")
                        all_good = False
                    else:
                        logger.warning(f"‚ö†Ô∏è {name}: Non disponible (optionnel)")
            except Exception as e:
                if config["required"]:
                    logger.error(f"‚ùå {name}: Erreur - {e}")
                    all_good = False
                else:
                    logger.warning(f"‚ö†Ô∏è {name}: Erreur - {e}")
        
        return all_good

    def install_dependencies(self) -> bool:
        """Installation d√©pendances Python"""
        logger.info("Installation dependencies Python...")
        
        # Packages requis
        required_packages = [
            "asyncio",
            "aiohttp", 
            "fastapi",
            "uvicorn",
            "prometheus-client",
            "requests",
            "numpy",
            "scikit-learn",
            "pandas"
        ]
        
        try:
            for package in required_packages:
                try:
                    __import__(package.replace('-', '_'))
                    logger.info(f"‚úÖ {package}: D√©j√† install√©")
                except ImportError:
                    logger.info(f"üì¶ Installation {package}...")
                    subprocess.run([
                        sys.executable, "-m", "pip", "install", package
                    ], check=True, capture_output=True)
                    logger.info(f"‚úÖ {package}: Install√©")
            
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erreur installation dependencies: {e}")
            return False

    def prepare_environment(self) -> bool:
        """Pr√©paration environnement de d√©ploiement"""
        logger.info("Preparation environnement...")
        
        try:
            # Cr√©ation dossiers n√©cessaires
            directories = [
                "logs",
                "data", 
                "config",
                "monitoring/prometheus/data",
                "monitoring/grafana/data",
                "security/certs",
                "security/secrets"
            ]
            
            for directory in directories:
                dir_path = self.project_root / directory
                dir_path.mkdir(parents=True, exist_ok=True)
                logger.info(f"‚úÖ Dossier cr√©√©: {directory}")
            
            # Configuration fichiers environnement
            env_content = """# Station Traffey√®re Environment
PROJECT_NAME=station-traffeyere-iot-ai-platform
ENVIRONMENT=development
LOG_LEVEL=INFO

# Prometheus
PROMETHEUS_PORT=9090
PROMETHEUS_DATA_RETENTION=15d

# Grafana  
GRAFANA_PORT=3001
GRAFANA_ADMIN_USER=admin
GRAFANA_ADMIN_PASSWORD=admin123

# IoT Generator
IOT_GENERATOR_PORT=8090
IOT_SENSORS_COUNT=127

# Edge AI
EDGE_AI_PORT=8091
AI_MODEL_TYPE=isolation_forest
LATENCY_TARGET_MS=0.28

# SOC Dashboard
SOC_DASHBOARD_PORT=8080
SOC_ALERTS_ENABLED=true
"""
            
            env_file = self.project_root / ".env"
            with open(env_file, 'w') as f:
                f.write(env_content)
            
            logger.info("‚úÖ Fichier .env cr√©√©")
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erreur pr√©paration environnement: {e}")
            return False

    def deploy_docker_services(self) -> bool:
        """D√©ploiement services Docker"""
        logger.info("Deploiement services Docker...")
        
        try:
            # V√©rifier si Docker est disponible
            subprocess.run(["docker", "ps"], check=True, capture_output=True)
            
            # Arr√™ter services existants si n√©cessaire
            logger.info("Arret services existants...")
            try:
                subprocess.run([
                    "docker-compose", "-f", "docker-compose.yml", "down"
                ], capture_output=True, timeout=30)
                
                subprocess.run([
                    "docker-compose", "-f", "docker-compose.monitoring.yml", "down"  
                ], capture_output=True, timeout=30)
            except:
                pass
            
            # D√©marrage services principaux
            logger.info("Demarrage services principaux...")
            result = subprocess.run([
                "docker-compose", "-f", "docker-compose.yml", "up", "-d"
            ], capture_output=True, text=True, timeout=120)
            
            if result.returncode != 0:
                logger.error(f"Erreur docker-compose principal: {result.stderr}")
                return False
            
            # Attendre que les services soient pr√™ts
            time.sleep(10)
            
            # V√©rifier statut services
            result = subprocess.run([
                "docker-compose", "-f", "docker-compose.yml", "ps"
            ], capture_output=True, text=True)
            
            logger.info("Services Docker d√©marr√©s:")
            for line in result.stdout.split('\n')[2:]:  # Skip headers
                if line.strip():
                    logger.info(f"  {line}")
            
            return True
            
        except Exception as e:
            logger.error(f"‚ùå Erreur d√©ploiement Docker: {e}")
            return False

    async def deploy_python_services(self) -> bool:
        """D√©ploiement services Python"""
        logger.info("Deploiement services Python...")
        
        python_services = []
        
        for service_name, config in self.service_config.items():
            if "path" in config:
                service_path = self.project_root / config["path"]
                if service_path.exists():
                    logger.info(f"Demarrage {service_name}...")
                    try:
                        # Lancer le service en arri√®re-plan
                        process = subprocess.Popen([
                            sys.executable, str(service_path)
                        ], stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                        
                        python_services.append({
                            "name": service_name,
                            "process": process,
                            "config": config
                        })
                        
                        # Attendre un peu pour que le service d√©marre
                        await asyncio.sleep(2)
                        
                        # V√©rifier si le service est encore actif
                        if process.poll() is None:
                            logger.info(f"‚úÖ {service_name}: D√©marr√© (PID: {process.pid})")
                            self.deployment_status[service_name] = "RUNNING"
                        else:
                            logger.error(f"‚ùå {service_name}: √âchec d√©marrage")
                            self.deployment_status[service_name] = "FAILED"
                            
                    except Exception as e:
                        logger.error(f"‚ùå {service_name}: Erreur - {e}")
                        self.deployment_status[service_name] = "ERROR"
                else:
                    logger.warning(f"‚ö†Ô∏è {service_name}: Fichier non trouv√© - {service_path}")
                    self.deployment_status[service_name] = "NOT_FOUND"
        
        # Sauvegarder r√©f√©rences des processus
        self.services = python_services
        return len([s for s in python_services if self.deployment_status[s["name"]] == "RUNNING"]) > 0

    def test_services_connectivity(self) -> Dict[str, Any]:
        """Test connectivit√© des services"""
        logger.info("Test connectivite services...")
        
        connectivity_results = {}
        
        # Services HTTP √† tester
        http_services = {
            "iot_generator": "http://localhost:8090/metrics",
            "edge_ai_engine": "http://localhost:8091/metrics", 
            "prometheus": "http://localhost:9090/-/healthy",
            "grafana": "http://localhost:3001/api/health",
            "soc_dashboard": "http://localhost:8080/health"
        }
        
        for service_name, url in http_services.items():
            try:
                import requests
                response = requests.get(url, timeout=10)
                if response.status_code == 200:
                    connectivity_results[service_name] = {
                        "status": "OK",
                        "response_time": response.elapsed.total_seconds(),
                        "url": url
                    }
                    logger.info(f"‚úÖ {service_name}: Connectivit√© OK ({response.elapsed.total_seconds():.3f}s)")
                else:
                    connectivity_results[service_name] = {
                        "status": "ERROR",
                        "http_code": response.status_code,
                        "url": url
                    }
                    logger.warning(f"‚ö†Ô∏è {service_name}: HTTP {response.status_code}")
                    
            except requests.exceptions.ConnectionError:
                connectivity_results[service_name] = {
                    "status": "CONNECTION_REFUSED",
                    "url": url
                }
                logger.warning(f"‚ö†Ô∏è {service_name}: Connexion refus√©e")
                
            except Exception as e:
                connectivity_results[service_name] = {
                    "status": "EXCEPTION",
                    "error": str(e),
                    "url": url
                }
                logger.error(f"‚ùå {service_name}: {e}")
        
        return connectivity_results

    def run_integration_tests(self) -> Dict[str, Any]:
        """Ex√©cution tests d'int√©gration"""
        logger.info("Execution tests integration...")
        
        test_results = {}
        
        # Test 1: Validation syst√®me final
        try:
            logger.info("Test: Validation syst√®me final...")
            result = subprocess.run([
                sys.executable, 
                str(self.project_root / "week-16-global-expansion/final_validation_system.py")
            ], capture_output=True, text=True, timeout=60)
            
            if "VALIDATION R√âUSSIE" in result.stdout or result.returncode == 0:
                test_results["final_validation"] = {
                    "status": "PASSED",
                    "description": "Syst√®me de validation finale RNCP"
                }
                logger.info("‚úÖ Test validation finale: R√âUSSI")
            else:
                test_results["final_validation"] = {
                    "status": "FAILED",
                    "error": result.stderr[:200]
                }
                logger.error("‚ùå Test validation finale: √âCHEC")
                
        except Exception as e:
            test_results["final_validation"] = {
                "status": "ERROR",
                "error": str(e)
            }
        
        # Test 2: Collecte m√©triques Prometheus
        try:
            logger.info("Test: Collecte m√©triques Prometheus...")
            import requests
            
            # Test m√©triques IoT
            response = requests.get("http://localhost:9090/api/v1/query?query=up", timeout=10)
            if response.status_code == 200:
                data = response.json()
                if data.get("status") == "success":
                    test_results["prometheus_metrics"] = {
                        "status": "PASSED",
                        "metrics_collected": len(data.get("data", {}).get("result", [])),
                        "description": "Collecte m√©triques Prometheus"
                    }
                    logger.info("‚úÖ Test m√©triques Prometheus: R√âUSSI")
                else:
                    test_results["prometheus_metrics"] = {
                        "status": "FAILED",
                        "error": "Pas de donn√©es"
                    }
            else:
                test_results["prometheus_metrics"] = {
                    "status": "FAILED",
                    "http_code": response.status_code
                }
                
        except Exception as e:
            test_results["prometheus_metrics"] = {
                "status": "ERROR", 
                "error": str(e)
            }
        
        # Test 3: Dashboard Grafana accessible
        try:
            logger.info("Test: Accessibilite Dashboard Grafana...")
            import requests
            
            response = requests.get("http://localhost:3001/api/health", timeout=10)
            if response.status_code == 200:
                test_results["grafana_dashboard"] = {
                    "status": "PASSED",
                    "description": "Dashboard Grafana accessible"
                }
                logger.info("‚úÖ Test Dashboard Grafana: R√âUSSI")
            else:
                test_results["grafana_dashboard"] = {
                    "status": "FAILED",
                    "http_code": response.status_code
                }
                
        except Exception as e:
            test_results["grafana_dashboard"] = {
                "status": "ERROR",
                "error": str(e)
            }
        
        return test_results

    def generate_deployment_report(self, connectivity_results: Dict, test_results: Dict) -> Dict[str, Any]:
        """G√©n√©ration rapport de d√©ploiement"""
        logger.info("Generation rapport deploiement...")
        
        # Calcul statistiques
        total_services = len(self.service_config)
        running_services = len([s for s, status in self.deployment_status.items() if status == "RUNNING"])
        connected_services = len([s for s, result in connectivity_results.items() if result.get("status") == "OK"])
        passed_tests = len([t for t, result in test_results.items() if result.get("status") == "PASSED"])
        total_tests = len(test_results)
        
        deployment_time = time.time() - self.start_time
        
        report = {
            "title": "RAPPORT DE D√âPLOIEMENT STATION TRAFFEY√àRE",
            "subtitle": "IoT/IA Platform - RNCP 39394 - Test Final",
            "timestamp": time.strftime("%Y-%m-%d %H:%M:%S"),
            "deployment_duration": f"{deployment_time:.2f} seconds",
            "summary": {
                "total_services": total_services,
                "running_services": running_services,
                "connected_services": connected_services,
                "success_rate": f"{(running_services/total_services*100):.1f}%",
                "connectivity_rate": f"{(connected_services/len(connectivity_results)*100):.1f}%" if connectivity_results else "0%",
                "tests_passed": f"{passed_tests}/{total_tests}",
                "overall_status": "SUCCESS" if running_services >= total_services * 0.7 else "PARTIAL" if running_services > 0 else "FAILED"
            },
            "services_status": self.deployment_status,
            "connectivity_results": connectivity_results,
            "test_results": test_results,
            "recommendations": []
        }
        
        # Recommandations bas√©es sur les r√©sultats
        if running_services < total_services:
            report["recommendations"].append("V√©rifier les services qui ne d√©marrent pas")
        
        if connected_services < len(connectivity_results) * 0.8:
            report["recommendations"].append("V√©rifier la configuration r√©seau et les ports")
        
        if passed_tests < total_tests:
            report["recommendations"].append("Analyser les √©checs de tests d'int√©gration")
        
        # Sauvegarde rapport
        report_path = self.project_root / "deployment_report.json"
        with open(report_path, 'w', encoding='utf-8') as f:
            json.dump(report, f, indent=2, ensure_ascii=False)
        
        logger.info(f"üìÑ Rapport sauvegard√©: {report_path}")
        return report

    async def deploy_complete_project(self) -> Dict[str, Any]:
        """D√©ploiement complet du projet"""
        logger.info("üöÄ D√âMARRAGE D√âPLOIEMENT COMPLET PROJET STATION TRAFFEY√àRE")
        logger.info("=" * 70)
        
        try:
            # √âtape 1: Pr√©requis
            if not self.check_prerequisites():
                return {"status": "FAILED", "step": "prerequisites"}
            
            # √âtape 2: D√©pendances
            if not self.install_dependencies():
                return {"status": "FAILED", "step": "dependencies"}
            
            # √âtape 3: Environnement
            if not self.prepare_environment():
                return {"status": "FAILED", "step": "environment"}
            
            # √âtape 4: Services Docker
            docker_success = self.deploy_docker_services()
            if not docker_success:
                logger.warning("‚ö†Ô∏è √âchec d√©ploiement Docker (continue sans Docker)")
            
            # √âtape 5: Services Python
            python_success = await self.deploy_python_services()
            
            # Attendre que tous les services soient pr√™ts
            logger.info("Attente stabilisation services...")
            await asyncio.sleep(5)
            
            # √âtape 6: Tests de connectivit√©
            connectivity_results = self.test_services_connectivity()
            
            # √âtape 7: Tests d'int√©gration
            test_results = self.run_integration_tests()
            
            # √âtape 8: Rapport final
            final_report = self.generate_deployment_report(connectivity_results, test_results)
            
            return {
                "status": "SUCCESS",
                "report": final_report
            }
            
        except Exception as e:
            logger.error(f"‚ùå Erreur critique d√©ploiement: {e}")
            return {"status": "ERROR", "error": str(e)}

    def cleanup_deployment(self):
        """Nettoyage apr√®s d√©ploiement"""
        logger.info("Nettoyage d√©ploiement...")
        
        # Arr√™t services Python
        for service in self.services:
            try:
                process = service["process"]
                if process.poll() is None:
                    process.terminate()
                    logger.info(f"‚úÖ Service {service['name']} arr√™t√©")
            except Exception as e:
                logger.error(f"‚ùå Erreur arr√™t {service['name']}: {e}")

def main():
    """Fonction principale"""
    print("üöÄ D√âPLOIEMENT COMPLET PROJET STATION TRAFFEY√àRE")
    print("IoT/IA Platform - RNCP 39394 - Test Final")
    print("=" * 70)
    
    deployer = ProjectDeployer()
    
    try:
        # D√©ploiement complet
        result = asyncio.run(deployer.deploy_complete_project())
        
        if result["status"] == "SUCCESS":
            report = result["report"]
            summary = report["summary"]
            
            print(f"\nüéâ D√âPLOIEMENT R√âUSSI !")
            print(f"üìä Services d√©ploy√©s : {summary['running_services']}/{summary['total_services']} ({summary['success_rate']})")
            print(f"üåê Connectivit√© : {summary['connectivity_rate']}")
            print(f"üß™ Tests : {summary['tests_passed']}")
            print(f"‚è±Ô∏è Dur√©e : {report['deployment_duration']}")
            print(f"üìÑ Rapport : deployment_report.json")
            
            print(f"\nüîó ACC√àS AUX SERVICES :")
            print(f"üìä Grafana Dashboard : http://localhost:3001")
            print(f"üìà Prometheus : http://localhost:9090")
            print(f"üè≠ G√©n√©rateur IoT : http://localhost:8090/metrics")
            print(f"ü§ñ Edge AI Engine : http://localhost:8091/metrics")
            print(f"üõ°Ô∏è SOC Dashboard : http://localhost:8080")
            
            print(f"\nüéì PROJET STATION TRAFFEY√àRE D√âPLOY√â AVEC SUCC√àS ! üèÜ")
            
        else:
            print(f"‚ùå √âchec d√©ploiement : {result.get('error', 'Erreur inconnue')}")
            
    except KeyboardInterrupt:
        print(f"\n‚ö†Ô∏è D√©ploiement interrompu par utilisateur")
    except Exception as e:
        print(f"‚ùå Erreur fatale : {e}")
    finally:
        # Nettoyage
        deployer.cleanup_deployment()
        print(f"\n‚úÖ Nettoyage termin√©")

if __name__ == "__main__":
    main()
